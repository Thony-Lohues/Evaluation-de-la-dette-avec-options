def Merton(v,M,r,y,sigma,T,theta,h,n) :
    
    d1 = (np.log(v / M) + ((r - y)* np.sqrt(h) + 1 / 2 * (sigma * np.sqrt(h)) ** 2) * n) / ((sigma * np.sqrt(h)) * np.sqrt(n))
    d2 = (np.log(v / M) + ((r - y)* np.sqrt(h) - 1 / 2 * (sigma * np.sqrt(h)) ** 2) * n) / ((sigma * np.sqrt(h)) * np.sqrt(n))
    N_d1 = sp.norm.cdf(d1)
    N_d2 = sp.norm.cdf(d2)
    S = v * np.exp((-y * np.sqrt(h)) * n) * N_d1 - M * N_d2 * np.exp((-r * np.sqrt(h)) * n)
    D = M * np.exp((-r * np.sqrt(h)) * n) * N_d2 + theta * v * np.exp((-y * np.sqrt(h)) * n) * (1 - N_d1)

    return D



def Dette_rachetable(three, callable_price, M, n, r, sigma, theta, h, y, T) :

    D = three.copy()
    
        
    for j in range(0, n):
        D[1+j*2, n-1] = np.minimum(Merton(three[1+j*2, n-1],M,r,y,sigma,h,theta,h,h), callable_price)

    u = np.exp(sigma * np.sqrt(h))
    d = np.exp(-sigma * np.sqrt(h))
    pi = (np.exp((r - y) * h) - d) / (u - d)

    for i in range (1, n) :
        for j in range (0, n-i) :
            D[i+j*2+1, n-i-1] = np.minimum((pi*D[i+j*2, n-i] + (1-pi)*D[i+j*2+2, n-i]) * np.exp(-r* h), callable_price)
        
    
    return D
