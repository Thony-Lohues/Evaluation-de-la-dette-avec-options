def binomial_three(v, sigma, n, h):
    u = np.exp(sigma * np.sqrt(h))
    d = np.exp(-sigma * np.sqrt(h))
    s = (n * 2 + 1, n + 1)
    arbre = np.zeros(s)
    z = int(s[0] / 2 - 0.5)
    arbre[z, 0] = v
    for i in range(1, n + 1):
        arbre[z - i, i] = v * u ** i
        arbre[z + i, i] = v * d ** i
        for j in range(i + 1, n + 1):
            arbre[z - i + j - i, j] = arbre[z - i, i] * d ** (j - i)
    return arbre
